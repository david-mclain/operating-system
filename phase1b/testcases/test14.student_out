phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 5
XXp1(): joining with first child
testcase_main(): after fork of first child 4
XXp2(): started
XXp2(): zap'ing process with pid_z=4
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
   1     0  init              6         Runnable
   2     1  sentinel          7         Runnable
   3     1  testcase_main     3         Runnable
   4     3  XXp1              1         
   5     4  XXp3              3         Running
   6     3  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 6
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 11
XXp1(): joining with first child
testcase_main(): after fork of first child 10
XXp2(): started
XXp2(): zap'ing process with pid_z=10
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
   7     0  init              6         Runnable
   8     7  sentinel          7         Runnable
   9     7  testcase_main     3         Runnable
  10     9  XXp1              1         
  11    10  XXp3              3         Running
  12     9  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 12
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 17
XXp1(): joining with first child
testcase_main(): after fork of first child 16
XXp2(): started
XXp2(): zap'ing process with pid_z=16
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  13     0  init              6         Runnable
  14    13  sentinel          7         Runnable
  15    13  testcase_main     3         Runnable
  16    15  XXp1              1         
  17    16  XXp3              3         Running
  18    15  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 18
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 23
XXp1(): joining with first child
testcase_main(): after fork of first child 22
XXp2(): started
XXp2(): zap'ing process with pid_z=22
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  19     0  init              6         Runnable
  20    19  sentinel          7         Runnable
  21    19  testcase_main     3         Runnable
  22    21  XXp1              1         
  23    22  XXp3              3         Running
  24    21  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 24
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 29
XXp1(): joining with first child
testcase_main(): after fork of first child 28
XXp2(): started
XXp2(): zap'ing process with pid_z=28
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  25     0  init              6         Runnable
  26    25  sentinel          7         Runnable
  27    25  testcase_main     3         Runnable
  28    27  XXp1              1         
  29    28  XXp3              3         Running
  30    27  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 30
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 35
XXp1(): joining with first child
testcase_main(): after fork of first child 34
XXp2(): started
XXp2(): zap'ing process with pid_z=34
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  31     0  init              6         Runnable
  32    31  sentinel          7         Runnable
  33    31  testcase_main     3         Runnable
  34    33  XXp1              1         
  35    34  XXp3              3         Running
  36    33  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 36
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 41
XXp1(): joining with first child
testcase_main(): after fork of first child 40
XXp2(): started
XXp2(): zap'ing process with pid_z=40
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  37     0  init              6         Runnable
  38    37  sentinel          7         Runnable
  39    37  testcase_main     3         Runnable
  40    39  XXp1              1         
  41    40  XXp3              3         Running
  42    39  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 42
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 47
XXp1(): joining with first child
testcase_main(): after fork of first child 46
XXp2(): started
XXp2(): zap'ing process with pid_z=46
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  43     0  init              6         Runnable
  44    43  sentinel          7         Runnable
  45    43  testcase_main     3         Runnable
  46    45  XXp1              1         
  47    46  XXp3              3         Running
  48    45  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 48
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 53
XXp1(): joining with first child
testcase_main(): after fork of first child 52
XXp2(): started
XXp2(): zap'ing process with pid_z=52
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  50    49  sentinel          7         Runnable
  51    49  testcase_main     3         Runnable
  52    51  XXp1              1         
  53    52  XXp3              3         Running
  54    51  XXp2              2         
  49     0  init              6         Runnable
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 54
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 59
XXp1(): joining with first child
testcase_main(): after fork of first child 58
XXp2(): started
XXp2(): zap'ing process with pid_z=58
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  55     0  init              6         Runnable
  56    55  sentinel          7         Runnable
  57    55  testcase_main     3         Runnable
  58    57  XXp1              1         
  59    58  XXp3              3         Running
  60    57  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 60
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 65
XXp1(): joining with first child
testcase_main(): after fork of first child 64
XXp2(): started
XXp2(): zap'ing process with pid_z=64
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  61     0  init              6         Runnable
  62    61  sentinel          7         Runnable
  63    61  testcase_main     3         Runnable
  64    63  XXp1              1         
  65    64  XXp3              3         Running
  66    63  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 66
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 71
XXp1(): joining with first child
testcase_main(): after fork of first child 70
XXp2(): started
XXp2(): zap'ing process with pid_z=70
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  67     0  init              6         Runnable
  68    67  sentinel          7         Runnable
  69    67  testcase_main     3         Runnable
  70    69  XXp1              1         
  71    70  XXp3              3         Running
  72    69  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 72
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 77
XXp1(): joining with first child
testcase_main(): after fork of first child 76
XXp2(): started
XXp2(): zap'ing process with pid_z=76
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  73     0  init              6         Runnable
  74    73  sentinel          7         Runnable
  75    73  testcase_main     3         Runnable
  76    75  XXp1              1         
  77    76  XXp3              3         Running
  78    75  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 78
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 83
XXp1(): joining with first child
testcase_main(): after fork of first child 82
XXp2(): started
XXp2(): zap'ing process with pid_z=82
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  79     0  init              6         Runnable
  80    79  sentinel          7         Runnable
  81    79  testcase_main     3         Runnable
  82    81  XXp1              1         
  83    82  XXp3              3         Running
  84    81  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 84
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 89
XXp1(): joining with first child
testcase_main(): after fork of first child 88
XXp2(): started
XXp2(): zap'ing process with pid_z=88
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  85     0  init              6         Runnable
  86    85  sentinel          7         Runnable
  87    85  testcase_main     3         Runnable
  88    87  XXp1              1         
  89    88  XXp3              3         Running
  90    87  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 90
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 95
XXp1(): joining with first child
testcase_main(): after fork of first child 94
XXp2(): started
XXp2(): zap'ing process with pid_z=94
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
  91     0  init              6         Runnable
  92    91  sentinel          7         Runnable
  93    91  testcase_main     3         Runnable
  94    93  XXp1              1         
  95    94  XXp3              3         Running
  96    93  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 96
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 101
XXp1(): joining with first child
testcase_main(): after fork of first child 100
XXp2(): started
XXp2(): zap'ing process with pid_z=100
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 100    99  XXp1              1         
 101   100  XXp3              3         Running
 102    99  XXp2              2         
  97     0  init              6         Runnable
  98    97  sentinel          7         Runnable
  99    97  testcase_main     3         Runnable
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 102
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 107
XXp1(): joining with first child
testcase_main(): after fork of first child 106
XXp2(): started
XXp2(): zap'ing process with pid_z=106
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 103     0  init              6         Runnable
 104   103  sentinel          7         Runnable
 105   103  testcase_main     3         Runnable
 106   105  XXp1              1         
 107   106  XXp3              3         Running
 108   105  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 108
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 113
XXp1(): joining with first child
testcase_main(): after fork of first child 112
XXp2(): started
XXp2(): zap'ing process with pid_z=112
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 109     0  init              6         Runnable
 110   109  sentinel          7         Runnable
 111   109  testcase_main     3         Runnable
 112   111  XXp1              1         
 113   112  XXp3              3         Running
 114   111  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 114
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 119
XXp1(): joining with first child
testcase_main(): after fork of first child 118
XXp2(): started
XXp2(): zap'ing process with pid_z=118
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 115     0  init              6         Runnable
 116   115  sentinel          7         Runnable
 117   115  testcase_main     3         Runnable
 118   117  XXp1              1         
 119   118  XXp3              3         Running
 120   117  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 120
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 125
XXp1(): joining with first child
testcase_main(): after fork of first child 124
XXp2(): started
XXp2(): zap'ing process with pid_z=124
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 121     0  init              6         Runnable
 122   121  sentinel          7         Runnable
 123   121  testcase_main     3         Runnable
 124   123  XXp1              1         
 125   124  XXp3              3         Running
 126   123  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 126
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 131
XXp1(): joining with first child
testcase_main(): after fork of first child 130
XXp2(): started
XXp2(): zap'ing process with pid_z=130
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 127     0  init              6         Runnable
 128   127  sentinel          7         Runnable
 129   127  testcase_main     3         Runnable
 130   129  XXp1              1         
 131   130  XXp3              3         Running
 132   129  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 132
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 137
XXp1(): joining with first child
testcase_main(): after fork of first child 136
XXp2(): started
XXp2(): zap'ing process with pid_z=136
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 133     0  init              6         Runnable
 134   133  sentinel          7         Runnable
 135   133  testcase_main     3         Runnable
 136   135  XXp1              1         
 137   136  XXp3              3         Running
 138   135  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 138
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 143
XXp1(): joining with first child
testcase_main(): after fork of first child 142
XXp2(): started
XXp2(): zap'ing process with pid_z=142
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 139     0  init              6         Runnable
 140   139  sentinel          7         Runnable
 141   139  testcase_main     3         Runnable
 142   141  XXp1              1         
 143   142  XXp3              3         Running
 144   141  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 144
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 149
XXp1(): joining with first child
testcase_main(): after fork of first child 148
XXp2(): started
XXp2(): zap'ing process with pid_z=148
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 150   147  XXp2              2         
 145     0  init              6         Runnable
 146   145  sentinel          7         Runnable
 147   145  testcase_main     3         Runnable
 148   147  XXp1              1         
 149   148  XXp3              3         Running
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 150
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 155
XXp1(): joining with first child
testcase_main(): after fork of first child 154
XXp2(): started
XXp2(): zap'ing process with pid_z=154
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 151     0  init              6         Runnable
 152   151  sentinel          7         Runnable
 153   151  testcase_main     3         Runnable
 154   153  XXp1              1         
 155   154  XXp3              3         Running
 156   153  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 156
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 161
XXp1(): joining with first child
testcase_main(): after fork of first child 160
XXp2(): started
XXp2(): zap'ing process with pid_z=160
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 157     0  init              6         Runnable
 158   157  sentinel          7         Runnable
 159   157  testcase_main     3         Runnable
 160   159  XXp1              1         
 161   160  XXp3              3         Running
 162   159  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 162
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 167
XXp1(): joining with first child
testcase_main(): after fork of first child 166
XXp2(): started
XXp2(): zap'ing process with pid_z=166
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 163     0  init              6         Runnable
 164   163  sentinel          7         Runnable
 165   163  testcase_main     3         Runnable
 166   165  XXp1              1         
 167   166  XXp3              3         Running
 168   165  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 168
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 173
XXp1(): joining with first child
testcase_main(): after fork of first child 172
XXp2(): started
XXp2(): zap'ing process with pid_z=172
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 169     0  init              6         Runnable
 170   169  sentinel          7         Runnable
 171   169  testcase_main     3         Runnable
 172   171  XXp1              1         
 173   172  XXp3              3         Running
 174   171  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 174
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 179
XXp1(): joining with first child
testcase_main(): after fork of first child 178
XXp2(): started
XXp2(): zap'ing process with pid_z=178
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 175     0  init              6         Runnable
 176   175  sentinel          7         Runnable
 177   175  testcase_main     3         Runnable
 178   177  XXp1              1         
 179   178  XXp3              3         Running
 180   177  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 180
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 185
XXp1(): joining with first child
testcase_main(): after fork of first child 184
XXp2(): started
XXp2(): zap'ing process with pid_z=184
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 181     0  init              6         Runnable
 182   181  sentinel          7         Runnable
 183   181  testcase_main     3         Runnable
 184   183  XXp1              1         
 185   184  XXp3              3         Running
 186   183  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 186
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 191
XXp1(): joining with first child
testcase_main(): after fork of first child 190
XXp2(): started
XXp2(): zap'ing process with pid_z=190
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 187     0  init              6         Runnable
 188   187  sentinel          7         Runnable
 189   187  testcase_main     3         Runnable
 190   189  XXp1              1         
 191   190  XXp3              3         Running
 192   189  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 192
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 197
XXp1(): joining with first child
testcase_main(): after fork of first child 196
XXp2(): started
XXp2(): zap'ing process with pid_z=196
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 193     0  init              6         Runnable
 194   193  sentinel          7         Runnable
 195   193  testcase_main     3         Runnable
 196   195  XXp1              1         
 197   196  XXp3              3         Running
 198   195  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 198
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 203
XXp1(): joining with first child
testcase_main(): after fork of first child 202
XXp2(): started
XXp2(): zap'ing process with pid_z=202
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 200   199  sentinel          7         Runnable
 201   199  testcase_main     3         Runnable
 202   201  XXp1              1         
 203   202  XXp3              3         Running
 204   201  XXp2              2         
 199     0  init              6         Runnable
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 204
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 209
XXp1(): joining with first child
testcase_main(): after fork of first child 208
XXp2(): started
XXp2(): zap'ing process with pid_z=208
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 205     0  init              6         Runnable
 206   205  sentinel          7         Runnable
 207   205  testcase_main     3         Runnable
 208   207  XXp1              1         
 209   208  XXp3              3         Running
 210   207  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 210
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 215
XXp1(): joining with first child
testcase_main(): after fork of first child 214
XXp2(): started
XXp2(): zap'ing process with pid_z=214
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 211     0  init              6         Runnable
 212   211  sentinel          7         Runnable
 213   211  testcase_main     3         Runnable
 214   213  XXp1              1         
 215   214  XXp3              3         Running
 216   213  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 216
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 221
XXp1(): joining with first child
testcase_main(): after fork of first child 220
XXp2(): started
XXp2(): zap'ing process with pid_z=220
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 217     0  init              6         Runnable
 218   217  sentinel          7         Runnable
 219   217  testcase_main     3         Runnable
 220   219  XXp1              1         
 221   220  XXp3              3         Running
 222   219  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 222
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 227
XXp1(): joining with first child
testcase_main(): after fork of first child 226
XXp2(): started
XXp2(): zap'ing process with pid_z=226
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 223     0  init              6         Runnable
 224   223  sentinel          7         Runnable
 225   223  testcase_main     3         Runnable
 226   225  XXp1              1         
 227   226  XXp3              3         Running
 228   225  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 228
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 233
XXp1(): joining with first child
testcase_main(): after fork of first child 232
XXp2(): started
XXp2(): zap'ing process with pid_z=232
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 229     0  init              6         Runnable
 230   229  sentinel          7         Runnable
 231   229  testcase_main     3         Runnable
 232   231  XXp1              1         
 233   232  XXp3              3         Running
 234   231  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 234
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 239
XXp1(): joining with first child
testcase_main(): after fork of first child 238
XXp2(): started
XXp2(): zap'ing process with pid_z=238
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 235     0  init              6         Runnable
 236   235  sentinel          7         Runnable
 237   235  testcase_main     3         Runnable
 238   237  XXp1              1         
 239   238  XXp3              3         Running
 240   237  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 240
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 245
XXp1(): joining with first child
testcase_main(): after fork of first child 244
XXp2(): started
XXp2(): zap'ing process with pid_z=244
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 241     0  init              6         Runnable
 242   241  sentinel          7         Runnable
 243   241  testcase_main     3         Runnable
 244   243  XXp1              1         
 245   244  XXp3              3         Running
 246   243  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 246
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 251
XXp1(): joining with first child
testcase_main(): after fork of first child 250
XXp2(): started
XXp2(): zap'ing process with pid_z=250
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 250   249  XXp1              1         
 251   250  XXp3              3         Running
 252   249  XXp2              2         
 247     0  init              6         Runnable
 248   247  sentinel          7         Runnable
 249   247  testcase_main     3         Runnable
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 252
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 257
XXp1(): joining with first child
testcase_main(): after fork of first child 256
XXp2(): started
XXp2(): zap'ing process with pid_z=256
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 253     0  init              6         Runnable
 254   253  sentinel          7         Runnable
 255   253  testcase_main     3         Runnable
 256   255  XXp1              1         
 257   256  XXp3              3         Running
 258   255  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 258
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 263
XXp1(): joining with first child
testcase_main(): after fork of first child 262
XXp2(): started
XXp2(): zap'ing process with pid_z=262
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 259     0  init              6         Runnable
 260   259  sentinel          7         Runnable
 261   259  testcase_main     3         Runnable
 262   261  XXp1              1         
 263   262  XXp3              3         Running
 264   261  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 264
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 269
XXp1(): joining with first child
testcase_main(): after fork of first child 268
XXp2(): started
XXp2(): zap'ing process with pid_z=268
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 265     0  init              6         Runnable
 266   265  sentinel          7         Runnable
 267   265  testcase_main     3         Runnable
 268   267  XXp1              1         
 269   268  XXp3              3         Running
 270   267  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 270
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 275
XXp1(): joining with first child
testcase_main(): after fork of first child 274
XXp2(): started
XXp2(): zap'ing process with pid_z=274
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 271     0  init              6         Runnable
 272   271  sentinel          7         Runnable
 273   271  testcase_main     3         Runnable
 274   273  XXp1              1         
 275   274  XXp3              3         Running
 276   273  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 276
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 281
XXp1(): joining with first child
testcase_main(): after fork of first child 280
XXp2(): started
XXp2(): zap'ing process with pid_z=280
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 277     0  init              6         Runnable
 278   277  sentinel          7         Runnable
 279   277  testcase_main     3         Runnable
 280   279  XXp1              1         
 281   280  XXp3              3         Running
 282   279  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 282
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 287
XXp1(): joining with first child
testcase_main(): after fork of first child 286
XXp2(): started
XXp2(): zap'ing process with pid_z=286
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 283     0  init              6         Runnable
 284   283  sentinel          7         Runnable
 285   283  testcase_main     3         Runnable
 286   285  XXp1              1         
 287   286  XXp3              3         Running
 288   285  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 288
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 293
XXp1(): joining with first child
testcase_main(): after fork of first child 292
XXp2(): started
XXp2(): zap'ing process with pid_z=292
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 289     0  init              6         Runnable
 290   289  sentinel          7         Runnable
 291   289  testcase_main     3         Runnable
 292   291  XXp1              1         
 293   292  XXp3              3         Running
 294   291  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 294
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 299
XXp1(): joining with first child
testcase_main(): after fork of first child 298
XXp2(): started
XXp2(): zap'ing process with pid_z=298
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 300   297  XXp2              2         
 295     0  init              6         Runnable
 296   295  sentinel          7         Runnable
 297   295  testcase_main     3         Runnable
 298   297  XXp1              1         
 299   298  XXp3              3         Running
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 300
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 305
XXp1(): joining with first child
testcase_main(): after fork of first child 304
XXp2(): started
XXp2(): zap'ing process with pid_z=304
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 301     0  init              6         Runnable
 302   301  sentinel          7         Runnable
 303   301  testcase_main     3         Runnable
 304   303  XXp1              1         
 305   304  XXp3              3         Running
 306   303  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 306
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 311
XXp1(): joining with first child
testcase_main(): after fork of first child 310
XXp2(): started
XXp2(): zap'ing process with pid_z=310
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 307     0  init              6         Runnable
 308   307  sentinel          7         Runnable
 309   307  testcase_main     3         Runnable
 310   309  XXp1              1         
 311   310  XXp3              3         Running
 312   309  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 312
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 317
XXp1(): joining with first child
testcase_main(): after fork of first child 316
XXp2(): started
XXp2(): zap'ing process with pid_z=316
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 313     0  init              6         Runnable
 314   313  sentinel          7         Runnable
 315   313  testcase_main     3         Runnable
 316   315  XXp1              1         
 317   316  XXp3              3         Running
 318   315  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 318
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 323
XXp1(): joining with first child
testcase_main(): after fork of first child 322
XXp2(): started
XXp2(): zap'ing process with pid_z=322
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 319     0  init              6         Runnable
 320   319  sentinel          7         Runnable
 321   319  testcase_main     3         Runnable
 322   321  XXp1              1         
 323   322  XXp3              3         Running
 324   321  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 324
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 329
XXp1(): joining with first child
testcase_main(): after fork of first child 328
XXp2(): started
XXp2(): zap'ing process with pid_z=328
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 325     0  init              6         Runnable
 326   325  sentinel          7         Runnable
 327   325  testcase_main     3         Runnable
 328   327  XXp1              1         
 329   328  XXp3              3         Running
 330   327  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 330
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 335
XXp1(): joining with first child
testcase_main(): after fork of first child 334
XXp2(): started
XXp2(): zap'ing process with pid_z=334
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 331     0  init              6         Runnable
 332   331  sentinel          7         Runnable
 333   331  testcase_main     3         Runnable
 334   333  XXp1              1         
 335   334  XXp3              3         Running
 336   333  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 336
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 341
XXp1(): joining with first child
testcase_main(): after fork of first child 340
XXp2(): started
XXp2(): zap'ing process with pid_z=340
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 337     0  init              6         Runnable
 338   337  sentinel          7         Runnable
 339   337  testcase_main     3         Runnable
 340   339  XXp1              1         
 341   340  XXp3              3         Running
 342   339  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 342
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 347
XXp1(): joining with first child
testcase_main(): after fork of first child 346
XXp2(): started
XXp2(): zap'ing process with pid_z=346
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 343     0  init              6         Runnable
 344   343  sentinel          7         Runnable
 345   343  testcase_main     3         Runnable
 346   345  XXp1              1         
 347   346  XXp3              3         Running
 348   345  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 348
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 353
XXp1(): joining with first child
testcase_main(): after fork of first child 352
XXp2(): started
XXp2(): zap'ing process with pid_z=352
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 350   349  sentinel          7         Runnable
 351   349  testcase_main     3         Runnable
 352   351  XXp1              1         
 353   352  XXp3              3         Running
 354   351  XXp2              2         
 349     0  init              6         Runnable
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 354
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 359
XXp1(): joining with first child
testcase_main(): after fork of first child 358
XXp2(): started
XXp2(): zap'ing process with pid_z=358
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 355     0  init              6         Runnable
 356   355  sentinel          7         Runnable
 357   355  testcase_main     3         Runnable
 358   357  XXp1              1         
 359   358  XXp3              3         Running
 360   357  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 360
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 365
XXp1(): joining with first child
testcase_main(): after fork of first child 364
XXp2(): started
XXp2(): zap'ing process with pid_z=364
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 361     0  init              6         Runnable
 362   361  sentinel          7         Runnable
 363   361  testcase_main     3         Runnable
 364   363  XXp1              1         
 365   364  XXp3              3         Running
 366   363  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 366
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 371
XXp1(): joining with first child
testcase_main(): after fork of first child 370
XXp2(): started
XXp2(): zap'ing process with pid_z=370
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 367     0  init              6         Runnable
 368   367  sentinel          7         Runnable
 369   367  testcase_main     3         Runnable
 370   369  XXp1              1         
 371   370  XXp3              3         Running
 372   369  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 372
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 377
XXp1(): joining with first child
testcase_main(): after fork of first child 376
XXp2(): started
XXp2(): zap'ing process with pid_z=376
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 373     0  init              6         Runnable
 374   373  sentinel          7         Runnable
 375   373  testcase_main     3         Runnable
 376   375  XXp1              1         
 377   376  XXp3              3         Running
 378   375  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 378
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 383
XXp1(): joining with first child
testcase_main(): after fork of first child 382
XXp2(): started
XXp2(): zap'ing process with pid_z=382
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 379     0  init              6         Runnable
 380   379  sentinel          7         Runnable
 381   379  testcase_main     3         Runnable
 382   381  XXp1              1         
 383   382  XXp3              3         Running
 384   381  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 384
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 389
XXp1(): joining with first child
testcase_main(): after fork of first child 388
XXp2(): started
XXp2(): zap'ing process with pid_z=388
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 385     0  init              6         Runnable
 386   385  sentinel          7         Runnable
 387   385  testcase_main     3         Runnable
 388   387  XXp1              1         
 389   388  XXp3              3         Running
 390   387  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 390
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 395
XXp1(): joining with first child
testcase_main(): after fork of first child 394
XXp2(): started
XXp2(): zap'ing process with pid_z=394
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 391     0  init              6         Runnable
 392   391  sentinel          7         Runnable
 393   391  testcase_main     3         Runnable
 394   393  XXp1              1         
 395   394  XXp3              3         Running
 396   393  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 396
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 401
XXp1(): joining with first child
testcase_main(): after fork of first child 400
XXp2(): started
XXp2(): zap'ing process with pid_z=400
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 400   399  XXp1              1         
 401   400  XXp3              3         Running
 402   399  XXp2              2         
 397     0  init              6         Runnable
 398   397  sentinel          7         Runnable
 399   397  testcase_main     3         Runnable
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 402
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 407
XXp1(): joining with first child
testcase_main(): after fork of first child 406
XXp2(): started
XXp2(): zap'ing process with pid_z=406
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 403     0  init              6         Runnable
 404   403  sentinel          7         Runnable
 405   403  testcase_main     3         Runnable
 406   405  XXp1              1         
 407   406  XXp3              3         Running
 408   405  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 408
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 413
XXp1(): joining with first child
testcase_main(): after fork of first child 412
XXp2(): started
XXp2(): zap'ing process with pid_z=412
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 409     0  init              6         Runnable
 410   409  sentinel          7         Runnable
 411   409  testcase_main     3         Runnable
 412   411  XXp1              1         
 413   412  XXp3              3         Running
 414   411  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 414
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 419
XXp1(): joining with first child
testcase_main(): after fork of first child 418
XXp2(): started
XXp2(): zap'ing process with pid_z=418
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 415     0  init              6         Runnable
 416   415  sentinel          7         Runnable
 417   415  testcase_main     3         Runnable
 418   417  XXp1              1         
 419   418  XXp3              3         Running
 420   417  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 420
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 425
XXp1(): joining with first child
testcase_main(): after fork of first child 424
XXp2(): started
XXp2(): zap'ing process with pid_z=424
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 421     0  init              6         Runnable
 422   421  sentinel          7         Runnable
 423   421  testcase_main     3         Runnable
 424   423  XXp1              1         
 425   424  XXp3              3         Running
 426   423  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 426
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 431
XXp1(): joining with first child
testcase_main(): after fork of first child 430
XXp2(): started
XXp2(): zap'ing process with pid_z=430
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 427     0  init              6         Runnable
 428   427  sentinel          7         Runnable
 429   427  testcase_main     3         Runnable
 430   429  XXp1              1         
 431   430  XXp3              3         Running
 432   429  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 432
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 437
XXp1(): joining with first child
testcase_main(): after fork of first child 436
XXp2(): started
XXp2(): zap'ing process with pid_z=436
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 433     0  init              6         Runnable
 434   433  sentinel          7         Runnable
 435   433  testcase_main     3         Runnable
 436   435  XXp1              1         
 437   436  XXp3              3         Running
 438   435  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 438
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 443
XXp1(): joining with first child
testcase_main(): after fork of first child 442
XXp2(): started
XXp2(): zap'ing process with pid_z=442
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 439     0  init              6         Runnable
 440   439  sentinel          7         Runnable
 441   439  testcase_main     3         Runnable
 442   441  XXp1              1         
 443   442  XXp3              3         Running
 444   441  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 444
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 449
XXp1(): joining with first child
testcase_main(): after fork of first child 448
XXp2(): started
XXp2(): zap'ing process with pid_z=448
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 450   447  XXp2              2         
 445     0  init              6         Runnable
 446   445  sentinel          7         Runnable
 447   445  testcase_main     3         Runnable
 448   447  XXp1              1         
 449   448  XXp3              3         Running
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 450
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 455
XXp1(): joining with first child
testcase_main(): after fork of first child 454
XXp2(): started
XXp2(): zap'ing process with pid_z=454
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 451     0  init              6         Runnable
 452   451  sentinel          7         Runnable
 453   451  testcase_main     3         Runnable
 454   453  XXp1              1         
 455   454  XXp3              3         Running
 456   453  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 456
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 461
XXp1(): joining with first child
testcase_main(): after fork of first child 460
XXp2(): started
XXp2(): zap'ing process with pid_z=460
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 457     0  init              6         Runnable
 458   457  sentinel          7         Runnable
 459   457  testcase_main     3         Runnable
 460   459  XXp1              1         
 461   460  XXp3              3         Running
 462   459  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 462
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 467
XXp1(): joining with first child
testcase_main(): after fork of first child 466
XXp2(): started
XXp2(): zap'ing process with pid_z=466
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 463     0  init              6         Runnable
 464   463  sentinel          7         Runnable
 465   463  testcase_main     3         Runnable
 466   465  XXp1              1         
 467   466  XXp3              3         Running
 468   465  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 468
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 473
XXp1(): joining with first child
testcase_main(): after fork of first child 472
XXp2(): started
XXp2(): zap'ing process with pid_z=472
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 469     0  init              6         Runnable
 470   469  sentinel          7         Runnable
 471   469  testcase_main     3         Runnable
 472   471  XXp1              1         
 473   472  XXp3              3         Running
 474   471  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 474
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 479
XXp1(): joining with first child
testcase_main(): after fork of first child 478
XXp2(): started
XXp2(): zap'ing process with pid_z=478
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 475     0  init              6         Runnable
 476   475  sentinel          7         Runnable
 477   475  testcase_main     3         Runnable
 478   477  XXp1              1         
 479   478  XXp3              3         Running
 480   477  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 480
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 485
XXp1(): joining with first child
testcase_main(): after fork of first child 484
XXp2(): started
XXp2(): zap'ing process with pid_z=484
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 481     0  init              6         Runnable
 482   481  sentinel          7         Runnable
 483   481  testcase_main     3         Runnable
 484   483  XXp1              1         
 485   484  XXp3              3         Running
 486   483  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 486
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 491
XXp1(): joining with first child
testcase_main(): after fork of first child 490
XXp2(): started
XXp2(): zap'ing process with pid_z=490
XXp3(): started
 PID  PPID  NAME              PRIORITY  STATE
 487     0  init              6         Runnable
 488   487  sentinel          7         Runnable
 489   487  testcase_main     3         Runnable
 490   489  XXp1              1         
 491   490  XXp3              3         Running
 492   489  XXp2              2         
XXp3(): terminating -- quit() should wake up XXp1() but XXp2() will continue to block, since it is zapping XXp1() instead of XXp3(), as it did in test13.
testcase_main(): after fork of second child 492
testcase_main(): performing join
phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: See test13.  This is the same, except that the PID that will be zap()ed is that of XXp1() - and thus the pid is stored by testcase_main() after the first fork().  This works much the same, except that when XXp3() terminates, only XXp1() wakes up (join) because XXp2() is trying to zap XXp1(), instead of XXp3() (as it did in test 13).
XXp1(): started
XXp1(): arg = 'XXp1'
XXp1(): executing fork of first child
XXp1(): fork1 of first child returned pid = 497
XXp1(): joining with first child
testcase_main(): after fork of first child 496
XXp2(): started
XXp2(): zap'ing process with pid_z=496
XXp3(): started
SIMULATOR TRAP: USLOSS_IntVec[USLOSS_CLOCK_INT] is NULL!

